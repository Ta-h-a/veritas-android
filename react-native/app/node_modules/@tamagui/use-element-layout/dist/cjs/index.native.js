"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var index_exports = {};
__export(index_exports, {
  createMeasure: () => createMeasure,
  createMeasureInWindow: () => createMeasureInWindow,
  createMeasureLayout: () => createMeasureLayout,
  enable: () => enable,
  getBoundingClientRectAsync: () => getBoundingClientRectAsync,
  getElementLayoutEvent: () => getElementLayoutEvent,
  measure: () => measure,
  measureInWindow: () => measureInWindow,
  measureLayout: () => measureLayout,
  measureNode: () => measureNode,
  setOnLayoutStrategy: () => setOnLayoutStrategy,
  useElementLayout: () => useElementLayout
});
module.exports = __toCommonJS(index_exports);
var import_constants = require("@tamagui/constants"), import_is_equal_shallow = require("@tamagui/is-equal-shallow"), LayoutHandlers = /* @__PURE__ */ new WeakMap(), Nodes = /* @__PURE__ */ new Set(), IntersectionState = /* @__PURE__ */ new WeakMap(), globalIntersectionObserver = null, strategy = "async";
function setOnLayoutStrategy(state) {
  strategy = state;
}
var NodeRectCache = /* @__PURE__ */ new WeakMap(), ParentRectCache = /* @__PURE__ */ new WeakMap(), LastChangeTime = /* @__PURE__ */ new WeakMap(), rAF = typeof window < "u" ? window.requestAnimationFrame : void 0, avoidUpdates = !0, queuedUpdates = /* @__PURE__ */ new Map();
function enable() {
  avoidUpdates && (avoidUpdates = !1, queuedUpdates && (queuedUpdates.forEach(function(cb) {
    return cb();
  }), queuedUpdates.clear()));
}
function startGlobalObservers() {
  !import_constants.isClient || globalIntersectionObserver || (globalIntersectionObserver = new IntersectionObserver(function(entries) {
    entries.forEach(function(entry) {
      var node = entry.target;
      IntersectionState.get(node) !== entry.isIntersecting && IntersectionState.set(node, entry.isIntersecting);
    });
  }, {
    threshold: 0
  }));
}
if (import_constants.isClient)
  if (rAF) {
    var supportsCheckVisibility = "checkVisibility" in document.body, BoundingRects = /* @__PURE__ */ new WeakMap();
    async function updateLayoutIfChanged(node) {
      if (IntersectionState.get(node) !== !1 && !(process.env.TAMAGUI_ONLAYOUT_VISIBILITY_CHECK === "1" && supportsCheckVisibility && !node.checkVisibility())) {
        var onLayout = LayoutHandlers.get(node);
        if (typeof onLayout == "function") {
          var parentNode = node.parentElement;
          if (parentNode) {
            var nodeRect, parentRect;
            if (strategy === "async") {
              var [nr, pr] = await Promise.all([
                BoundingRects.get(node) || getBoundingClientRectAsync(node),
                BoundingRects.get(parentNode) || getBoundingClientRectAsync(parentNode)
              ]);
              if (nr === !1 || pr === !1)
                return;
              nodeRect = nr, parentRect = pr;
            } else
              nodeRect = node.getBoundingClientRect(), parentRect = parentNode.getBoundingClientRect();
            var cachedRect = NodeRectCache.get(node), cachedParentRect = NodeRectCache.get(parentNode);
            if (!cachedRect || // has changed one rect
            // @ts-expect-error DOMRectReadOnly can go into object
            !(0, import_is_equal_shallow.isEqualShallow)(cachedRect, nodeRect) && // @ts-expect-error DOMRectReadOnly can go into object
            (!cachedParentRect || !(0, import_is_equal_shallow.isEqualShallow)(cachedParentRect, parentRect))) {
              NodeRectCache.set(node, nodeRect), ParentRectCache.set(parentNode, parentRect);
              var event = getElementLayoutEvent(nodeRect, parentRect);
              avoidUpdates ? queuedUpdates.set(node, function() {
                return onLayout(event);
              }) : onLayout(event);
            }
          }
        }
      }
    }
    rAF(layoutOnAnimationFrame);
    var frameCount = 0, userSkipVal = process.env.TAMAGUI_LAYOUT_FRAME_SKIP, RUN_EVERY_X_FRAMES = userSkipVal ? +userSkipVal : 10;
    async function layoutOnAnimationFrame() {
      if (strategy !== "off") {
        if (!Nodes.size || frameCount++ % RUN_EVERY_X_FRAMES !== 0) {
          rAF(layoutOnAnimationFrame);
          return;
        }
        frameCount === Number.MAX_SAFE_INTEGER && (frameCount = 0), await new Promise(function(res) {
          var io = new IntersectionObserver(function(entries) {
            io.disconnect();
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator2 = entries[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
                var entry = _step2.value;
                BoundingRects.set(entry.target, entry.boundingClientRect);
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
            res();
          }, {
            threshold: 0
          }), _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
          try {
            for (var _iterator = Nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
              var node = _step.value;
              node.parentElement instanceof HTMLElement && (io.observe(node), io.observe(node.parentElement));
            }
          } catch (err) {
            _didIteratorError = !0, _iteratorError = err;
          } finally {
            try {
              !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError)
                throw _iteratorError;
            }
          }
        }), Nodes.forEach(function(node) {
          updateLayoutIfChanged(node);
        });
      }
      rAF(layoutOnAnimationFrame);
    }
  } else
    process.env.NODE_ENV === "development" && console.warn("No requestAnimationFrame - please polyfill for onLayout to work correctly");
var getElementLayoutEvent = function(nodeRect, parentRect) {
  return {
    nativeEvent: {
      layout: getRelativeDimensions(nodeRect, parentRect),
      target: nodeRect
    },
    timeStamp: Date.now()
  };
}, getRelativeDimensions = function(a, b) {
  var { height, left, top, width } = a, x = left - b.left, y = top - b.top;
  return {
    x,
    y,
    width,
    height,
    pageX: a.left,
    pageY: a.top
  };
};
function useElementLayout(ref, onLayout) {
  var _ref_current, node = ensureWebElement((_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.host);
  node && onLayout && LayoutHandlers.set(node, onLayout), (0, import_constants.useIsomorphicLayoutEffect)(function() {
    var _ref_current2;
    if (onLayout) {
      var node2 = (_ref_current2 = ref.current) === null || _ref_current2 === void 0 ? void 0 : _ref_current2.host;
      if (node2) {
        Nodes.add(node2), startGlobalObservers(), globalIntersectionObserver && (globalIntersectionObserver.observe(node2), IntersectionState.set(node2, !0));
        var parentNode = node2.parentNode;
        return parentNode && onLayout(getElementLayoutEvent(node2.getBoundingClientRect(), parentNode.getBoundingClientRect())), function() {
          Nodes.delete(node2), LayoutHandlers.delete(node2), NodeRectCache.delete(node2), LastChangeTime.delete(node2), IntersectionState.delete(node2), globalIntersectionObserver && globalIntersectionObserver.unobserve(node2);
        };
      }
    }
  }, [
    ref,
    !!onLayout
  ]);
}
function ensureWebElement(x) {
  if (!(typeof HTMLElement > "u"))
    return x instanceof HTMLElement ? x : void 0;
}
var getBoundingClientRectAsync = function(node) {
  return new Promise(function(res) {
    if (!node || node.nodeType !== 1) return res(!1);
    var io = new IntersectionObserver(function(entries) {
      return io.disconnect(), res(entries[0].boundingClientRect);
    }, {
      threshold: 0
    });
    io.observe(node);
  });
}, measureNode = async function(node, relativeTo) {
  var relativeNode = relativeTo || (node == null ? void 0 : node.parentElement);
  if (relativeNode instanceof HTMLElement) {
    var [nodeDim, relativeNodeDim] = await Promise.all([
      getBoundingClientRectAsync(node),
      getBoundingClientRectAsync(relativeNode)
    ]);
    if (relativeNodeDim && nodeDim)
      return getRelativeDimensions(nodeDim, relativeNodeDim);
  }
  return null;
}, measure = async function(node, callback) {
  var out = await measureNode(node, node.parentNode instanceof HTMLElement ? node.parentNode : null);
  return out && (callback == null || callback(out.x, out.y, out.width, out.height, out.pageX, out.pageY)), out;
};
function createMeasure(node) {
  return function(callback) {
    return measure(node, callback);
  };
}
var measureInWindow = async function(node, callback) {
  var out = await measureNode(node, null);
  return out && (callback == null || callback(out.pageX, out.pageY, out.width, out.height)), out;
}, createMeasureInWindow = function(node) {
  return function(callback) {
    return measureInWindow(node, callback);
  };
}, measureLayout = async function(node, relativeNode, callback) {
  var out = await measureNode(node, relativeNode);
  return out && (callback == null || callback(out.x, out.y, out.width, out.height, out.pageX, out.pageY)), out;
};
function createMeasureLayout(node) {
  return function(relativeTo, callback) {
    return measureLayout(node, relativeTo, callback);
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createMeasure,
  createMeasureInWindow,
  createMeasureLayout,
  enable,
  getBoundingClientRectAsync,
  getElementLayoutEvent,
  measure,
  measureInWindow,
  measureLayout,
  measureNode,
  setOnLayoutStrategy,
  useElementLayout
});
//# sourceMappingURL=index.js.map
