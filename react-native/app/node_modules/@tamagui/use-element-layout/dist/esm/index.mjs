import { isClient, useIsomorphicLayoutEffect } from "@tamagui/constants";
import { isEqualShallow } from "@tamagui/is-equal-shallow";
const LayoutHandlers = /* @__PURE__ */new WeakMap(),
  Nodes = /* @__PURE__ */new Set(),
  IntersectionState = /* @__PURE__ */new WeakMap();
let globalIntersectionObserver = null,
  strategy = "async";
function setOnLayoutStrategy(state) {
  strategy = state;
}
const NodeRectCache = /* @__PURE__ */new WeakMap(),
  ParentRectCache = /* @__PURE__ */new WeakMap(),
  LastChangeTime = /* @__PURE__ */new WeakMap(),
  rAF = typeof window < "u" ? window.requestAnimationFrame : void 0;
let avoidUpdates = !0;
const queuedUpdates = /* @__PURE__ */new Map();
function enable() {
  avoidUpdates && (avoidUpdates = !1, queuedUpdates && (queuedUpdates.forEach(cb => cb()), queuedUpdates.clear()));
}
function startGlobalObservers() {
  !isClient || globalIntersectionObserver || (globalIntersectionObserver = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      const node = entry.target;
      IntersectionState.get(node) !== entry.isIntersecting && IntersectionState.set(node, entry.isIntersecting);
    });
  }, {
    threshold: 0
  }));
}
if (isClient) if (rAF) {
  const supportsCheckVisibility = "checkVisibility" in document.body,
    BoundingRects = /* @__PURE__ */new WeakMap();
  async function updateLayoutIfChanged(node) {
    if (IntersectionState.get(node) === !1 || process.env.TAMAGUI_ONLAYOUT_VISIBILITY_CHECK === "1" && supportsCheckVisibility && !node.checkVisibility()) return;
    const onLayout = LayoutHandlers.get(node);
    if (typeof onLayout != "function") return;
    const parentNode = node.parentElement;
    if (!parentNode) return;
    let nodeRect, parentRect;
    if (strategy === "async") {
      const [nr, pr] = await Promise.all([BoundingRects.get(node) || getBoundingClientRectAsync(node), BoundingRects.get(parentNode) || getBoundingClientRectAsync(parentNode)]);
      if (nr === !1 || pr === !1) return;
      nodeRect = nr, parentRect = pr;
    } else nodeRect = node.getBoundingClientRect(), parentRect = parentNode.getBoundingClientRect();
    const cachedRect = NodeRectCache.get(node),
      cachedParentRect = NodeRectCache.get(parentNode);
    if (!cachedRect ||
    // has changed one rect
    // @ts-expect-error DOMRectReadOnly can go into object
    !isEqualShallow(cachedRect, nodeRect) && (
    // @ts-expect-error DOMRectReadOnly can go into object
    !cachedParentRect || !isEqualShallow(cachedParentRect, parentRect))) {
      NodeRectCache.set(node, nodeRect), ParentRectCache.set(parentNode, parentRect);
      const event = getElementLayoutEvent(nodeRect, parentRect);
      avoidUpdates ? queuedUpdates.set(node, () => onLayout(event)) : onLayout(event);
    }
  }
  rAF(layoutOnAnimationFrame);
  let frameCount = 0;
  const userSkipVal = process.env.TAMAGUI_LAYOUT_FRAME_SKIP,
    RUN_EVERY_X_FRAMES = userSkipVal ? +userSkipVal : 10;
  async function layoutOnAnimationFrame() {
    if (strategy !== "off") {
      if (!Nodes.size || frameCount++ % RUN_EVERY_X_FRAMES !== 0) {
        rAF(layoutOnAnimationFrame);
        return;
      }
      frameCount === Number.MAX_SAFE_INTEGER && (frameCount = 0), await new Promise(res => {
        const io = new IntersectionObserver(entries => {
          io.disconnect();
          for (const entry of entries) BoundingRects.set(entry.target, entry.boundingClientRect);
          res();
        }, {
          threshold: 0
        });
        for (const node of Nodes) node.parentElement instanceof HTMLElement && (io.observe(node), io.observe(node.parentElement));
      }), Nodes.forEach(node => {
        updateLayoutIfChanged(node);
      });
    }
    rAF(layoutOnAnimationFrame);
  }
} else process.env.NODE_ENV === "development" && console.warn("No requestAnimationFrame - please polyfill for onLayout to work correctly");
const getElementLayoutEvent = (nodeRect, parentRect) => ({
    nativeEvent: {
      layout: getRelativeDimensions(nodeRect, parentRect),
      target: nodeRect
    },
    timeStamp: Date.now()
  }),
  getRelativeDimensions = (a, b) => {
    const {
        height,
        left,
        top,
        width
      } = a,
      x = left - b.left,
      y = top - b.top;
    return {
      x,
      y,
      width,
      height,
      pageX: a.left,
      pageY: a.top
    };
  };
function useElementLayout(ref, onLayout) {
  const node = ensureWebElement(ref.current?.host);
  node && onLayout && LayoutHandlers.set(node, onLayout), useIsomorphicLayoutEffect(() => {
    if (!onLayout) return;
    const node2 = ref.current?.host;
    if (!node2) return;
    Nodes.add(node2), startGlobalObservers(), globalIntersectionObserver && (globalIntersectionObserver.observe(node2), IntersectionState.set(node2, !0));
    const parentNode = node2.parentNode;
    return parentNode && onLayout(getElementLayoutEvent(node2.getBoundingClientRect(), parentNode.getBoundingClientRect())), () => {
      Nodes.delete(node2), LayoutHandlers.delete(node2), NodeRectCache.delete(node2), LastChangeTime.delete(node2), IntersectionState.delete(node2), globalIntersectionObserver && globalIntersectionObserver.unobserve(node2);
    };
  }, [ref, !!onLayout]);
}
function ensureWebElement(x) {
  if (!(typeof HTMLElement > "u")) return x instanceof HTMLElement ? x : void 0;
}
const getBoundingClientRectAsync = node => new Promise(res => {
    if (!node || node.nodeType !== 1) return res(!1);
    const io = new IntersectionObserver(entries => (io.disconnect(), res(entries[0].boundingClientRect)), {
      threshold: 0
    });
    io.observe(node);
  }),
  measureNode = async (node, relativeTo) => {
    const relativeNode = relativeTo || node?.parentElement;
    if (relativeNode instanceof HTMLElement) {
      const [nodeDim, relativeNodeDim] = await Promise.all([getBoundingClientRectAsync(node), getBoundingClientRectAsync(relativeNode)]);
      if (relativeNodeDim && nodeDim) return getRelativeDimensions(nodeDim, relativeNodeDim);
    }
    return null;
  },
  measure = async (node, callback) => {
    const out = await measureNode(node, node.parentNode instanceof HTMLElement ? node.parentNode : null);
    return out && callback?.(out.x, out.y, out.width, out.height, out.pageX, out.pageY), out;
  };
function createMeasure(node) {
  return callback => measure(node, callback);
}
const measureInWindow = async (node, callback) => {
    const out = await measureNode(node, null);
    return out && callback?.(out.pageX, out.pageY, out.width, out.height), out;
  },
  createMeasureInWindow = node => callback => measureInWindow(node, callback),
  measureLayout = async (node, relativeNode, callback) => {
    const out = await measureNode(node, relativeNode);
    return out && callback?.(out.x, out.y, out.width, out.height, out.pageX, out.pageY), out;
  };
function createMeasureLayout(node) {
  return (relativeTo, callback) => measureLayout(node, relativeTo, callback);
}
export { createMeasure, createMeasureInWindow, createMeasureLayout, enable, getBoundingClientRectAsync, getElementLayoutEvent, measure, measureInWindow, measureLayout, measureNode, setOnLayoutStrategy, useElementLayout };
//# sourceMappingURL=index.mjs.map
